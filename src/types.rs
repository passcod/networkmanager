use bitflags::bitflags;
use num_derive::FromPrimitive;

bitflags! {
    /// Capabilities of a specific device.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NMCapability)
    ///
    /// The range `0x7000` to `0x7FFF` is unused by NetworkManager, and can be used by extensions.
    /// This bitflag is read using [`CapabilityFlags::from_bits_retain()`] so that any bits set by
    /// extensions can be read without special support.
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct CapabilityFlags: u32 {
        /// Teams can be managed.
        ///
        /// This means the team device plugin is loaded.
        const TEAM = 1;

        /// OpenVSwitch can be managed.
        ///
        /// This means the OVS device plugin is loaded.
        const DNS_RC = 2;
    }
}

bitflags! {
    /// Specify what to reload.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/gdbus-org.freedesktop.NetworkManager.html#gdbus-method-org-freedesktop-NetworkManager.Reload)
    ///
    /// The [default value of `ReloadFlags`](ReloadFlags#default) (equivalent to [`ReloadFlags::empty()`]) performs a
    /// full reload, akin to sending SIGHUP to the NetworkManager daemon, and includes the behaviour of all flags.
    /// Setting a bit performs instead only the specified action(s).
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct ReloadFlags: u32 {
        /// Reload the NetworkManager configuration from disk.
        const CONFIGURATION = 0x01;

        /// Update the DNS configuration; generally means to rewrite `/etc/resolv.conf`.
        const DNS_RC = 0x02;

        /// Restart the DNS plugin, if one is in use.
        const DNS_PLUGIN = 0x04;
    }
}

impl Default for ReloadFlags {
    fn default() -> Self {
        ReloadFlags::empty()
    }
}

bitflags! {
    /// Flags for a connection.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NMSettingsConnectionFlags)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct ConnectionFlags: u32 {
        /// The connection is not saved to disk.
        ///
        /// This either means that the connection is in-memory only and currently is not backed by a
        /// file, or that the connection is backed by a file, but has modifications in-memory that
        /// were not persisted to disk.
        const UNSAVED = 0x01;

        /// A connection is "generated" if it was generated by NetworkManager.
        ///
        /// If the connection gets modified or saved by the user, the flag gets cleared. A
        /// generated is also `UNSAVED` and has no backing file as it is in-memory only.
        const GENERATED = 0x02;

        /// The connection will be deleted when it disconnects.
        ///
        /// That is for in-memory connections (unsaved), which are currently active but deleted on
        /// disconnect. Volatile connections are always unsaved, but they also have no backing file
        /// on disk and are entirely in-memory only.
        const VOLATILE = 0x04;

        /// The profile was generated to represent an external configuration of a networking device.
        const EXTERNAL = 0x08;
    }
}

bitflags! {
    /// Flags for a network interface.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NMDeviceInterfaceFlags)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct DeviceInterfaceFlags: u32 {
        /// The interface is enabled from the administrative point of view.
        ///
        /// Corresponds to kernel `IFF_UP`.
        const UP = 0x1;

        /// The physical link is up.
        ///
        /// Corresponds to kernel `IFF_LOWER_UP`.
        const LOWER_UP = 0x2;

        /// Receive all packets.
        ///
        /// Corresponds to kernel `IFF_PROMISC`.
        const PROMISCUOUS = 0x4;

        /// The interface has carrier.
        ///
        /// In most cases this is equal to the value of `LOWER_UP`. However some devices have a
        /// non-standard carrier detection mechanism.
        const CARRIER = 0x10000;

        /// The interface is enabled for LLDP.
        const LLDP_CLIENT_ENABLED = 0x20000;
    }
}

#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum ConnectivityState {
    Unknown = 0,
    None = 1,
    Portal = 2,
    Limited = 3,
    Full = 4,
}

#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum DeviceType {
    Unknown = 0,
    Ethernet = 1,
    Wifi = 2,
    Unused1 = 3,
    Unused2 = 4,
    Bt = 5,
    OlpcMesh = 6,
    Wimax = 7,
    Modem = 8,
    Infiniband = 9,
    Bond = 10,
    Vlan = 11,
    Adsl = 12,
    Bridge = 13,
    Generic = 14,
    Team = 15,
    Tun = 16,
    IpTunnel = 17,
    Macvlan = 18,
    Vxlan = 19,
    Veth = 20,
    Macsec = 21,
    Dummy = 22,
    Ppp = 23,
    OvsInterface = 24,
    OvsPort = 25,
    OvsBridge = 26,
    Wpan = 27,
    SixLowpan = 28,
    Wireguard = 29,
    WifiP2p = 30,
    Vrf = 31,
    Loopback = 32,
}

bitflags! {
    /// Flags describing the current activation state.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NMActivationStateFlags)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct ActivationStateFlags: u32 {
        /// The device is a master.
        const IS_MASTER = 0x1;

        /// The device is a slave.
        const IS_SLAVE = 0x2;

        /// Layer2 is activated and ready.
        const LAYER2_READY = 0x4;

        /// IPv4 setting is completed.
        const IPV4_READY = 0x8;

        /// IPv6 setting is completed.
        const IPV6_READY = 0x10;

        /// The master has any slave devices attached.
        ///
        /// This only makes sense if the device is a master.
        const MASTER_HAS_SLAVES = 0x20;

        /// The lifetime of the activation is bound to the visibility of the connection profile,
        /// which in turn depends on `connection.permissions` and whether a session for the user
        /// exists.
        const LIFETIME_BOUND_TO_PROFILE_VISIBILITY = 0x40;

        /// The active connection was generated to represent an external configuration of a
        /// networking device.
        const EXTERNAL = 0x80;
    }
}

#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum ActiveConnectionState {
    Unknown = 0,
    Activating = 1,
    Activated = 2,
    Deactivating = 3,
    Deactivated = 4,
}

/// The state of a network device.
#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum DeviceState {
    /// The device's state is unknown.
    Unknown = 0,

    /// The device is recognized, but not managed by NetworkManager.
    Unmanaged = 10,

    /// the device is managed by NetworkManager, but is not available for use.
    ///
    /// Reasons may include the wireless switched off, missing firmware, no ethernet carrier,
    /// missing supplicant or modem manager, etc.
    Unavailable = 20,

    /// The device can be activated, but is currently idle and not connected to a network.
    Disconnected = 30,

    /// The device is preparing the connection to the network.
    ///
    /// This may include operations like changing the MAC address, setting physical link properties,
    /// and anything else required to connect to the requested network.
    Preparing = 40,

    /// The device is connecting to the requested network.
    ///
    /// This may include operations like associating with the Wi-Fi AP, dialing the modem,
    /// connecting to the remote Bluetooth device, etc.
    Configuring = 50,

    /// The device requires more information to continue connecting to the requested network.
    ///
    /// This includes secrets like WiFi passphrases, login passwords, PIN codes, etc.
    NeedsAuth = 60,

    /// The device is requesting IPv4 and/or IPv6 addresses and routing information from the network.
    ConfiguringIP = 70,

    /// The device is checking whether further action is required for the requested network
    /// connection.
    ///
    /// This may include checking whether only local network access is available, whether a captive
    /// portal is blocking access to the Internet, etc.
    CheckingIP = 80,

    /// The device is waiting for a secondary connection (like a VPN) which must activate before
    /// this device can be activated.
    Secondaries = 90,

    /// The device has a network connection, either local or global.
    Activated = 100,

    /// A disconnection from the current network connection was requested, and the device is
    /// cleaning up resources used for that connection.
    ///
    /// The network connection may still be valid.
    Deactivating = 110,

    /// The device failed to connect to the requested network and is cleaning up the connection
    /// request.
    Failed = 120,
}

/// The reason a network device changed to its current state.
// TODO: docs
#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum DeviceStateReason {
    None = 0,
    Unknown = 1,
    NowManaged = 2,
    NowUnmanaged = 3,
    ConfigFailed = 4,
    IpConfigUnavailable = 5,
    IpConfigExpired = 6,
    NoSecrets = 7,
    SupplicantDisconnect = 8,
    SupplicantConfigFailed = 9,
    SupplicantFailed = 10,
    SupplicantTimeout = 11,
    PppStartFailed = 12,
    PppDisconnect = 13,
    PppFailed = 14,
    DhcpStartFailed = 15,
    DhcpError = 16,
    DhcpFailed = 17,
    SharedStartFailed = 18,
    SharedFailed = 19,
    AutoipStartFailed = 20,
    AutoipError = 21,
    AutoipFailed = 22,
    ModemBusy = 23,
    ModemNoDialTone = 24,
    ModemNoCarrier = 25,
    ModemDialTimeout = 26,
    ModemDialFailed = 27,
    ModemInitFailed = 28,
    GsmApnFailed = 29,
    GsmRegistrationNotSearching = 30,
    GsmRegistrationDenied = 31,
    GsmRegistrationTimeout = 32,
    GsmRegistrationFailed = 33,
    GsmPinCheckFailed = 34,
    FirmwareMissing = 35,
    Removed = 36,
    Sleeping = 37,
    ConnectionRemoved = 38,
    UserRequested = 39,
    Carrier = 40,
    ConnectionAssumed = 41,
    SupplicantAvailable = 42,
    ModemNotFound = 43,
    BtFailed = 44,
    GsmSimNotInserted = 45,
    GsmSimPinRequired = 46,
    GsmSimPukRequired = 47,
    GsmSimWrong = 48,
    InfinibandMode = 49,
    DependencyFailed = 50,
    Br2684Failed = 51,
    ModemManagerUnavailable = 52,
    SsidNotFound = 53,
    SecondaryConnectionFailed = 54,
    DcbFcoeFailed = 55,
    TeamdControlFailed = 56,
    ModemFailed = 57,
    ModemAvailable = 58,
    SimPinIncorrect = 59,
    NewActivation = 60,
    ParentChanged = 61,
    ParentManagedChanged = 62,
    OvsdbFailed = 63,
    IpAddressDuplicate = 64,
    IpMethodUnsupported = 65,
    SriovConfigurationFailed = 66,
    PeerNotFound = 67,
}

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// pub enum NMDeviceCapabilities {
//     NmDeviceCapNone = 0,
//     NmDeviceCapNmSupported = 1,
//     NmDeviceCapCarrierDetect = 2,
//     NmDeviceCapIsSoftware = 4,
//     NmDeviceCapSriov = 8,
// }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// pub enum NMDeviceWifiCapabilities {
//     NmWifiDeviceCapNone = 0,
//     NmWifiDeviceCapCipherWep40 = 1,
//     NmWifiDeviceCapCipherWep104 = 2,
//     NmWifiDeviceCapCipherTkip = 4,
//     NmWifiDeviceCapCipherCcmp = 8,
//     NmWifiDeviceCapWpa = 16,
//     NmWifiDeviceCapRsn = 32,
//     NmWifiDeviceCapAp = 64,
//     NmWifiDeviceCapAdhoc = 128,
//     NmWifiDeviceCapFreqValid = 256,
//     NmWifiDeviceCapFreq2ghz = 512,
//     NmWifiDeviceCapFreq5ghz = 1024,
//     NmWifiDeviceCapMesh = 4096,
//     NmWifiDeviceCapIbssRsn = 8192,
// }

bitflags! {
    /// Flags describing Wi-Fi access point capabilities.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NM80211ApFlags)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct AccessPointCapabilityFlags: u32 {
        /// Requires authentication and encryption (usually means WEP).
        const PRIVACY = 0x1;

        /// Supports some WPS method.
        const WPS = 0x2;

        /// Supports push-button WPS.
        const WPS_PUSH_BUTTON = 0x4;

        /// Supports PIN-based WPS.
        const WPS_PIN = 0x8;
    }
}

bitflags! {
    /// Flags describing Wi-Fi access point security properties.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NM80211ApSecurityFlags)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct AccessPointSecurityFlags: u32 {
        /// 40/64-bit WEP is supported for pairwise/unicast encryption.
        const PAIR_WEP40 = 0x1;

        /// 104/128-bit WEP is supported for pairwise/unicast encryption.
        const PAIR_WEP104 = 0x2;

        /// TKIP is supported for pairwise/unicast encryption.
        const PAIR_TKIP = 0x4;

        /// AES/CCMP is supported for pairwise/unicast encryption.
        const PAIR_CCMP = 0x8;

        /// 40/64-bit WEP is supported for group/broadcast encryption.
        const GROUP_WEP40 = 0x10;

        /// 104/128-bit WEP is supported for group/broadcast encryption.
        const GROUP_WEP104 = 0x20;

        /// TKIP is supported for group/broadcast encryption.
        const GROUP_TKIP = 0x40;

        /// AES/CCMP is supported for group/broadcast encryption.
        const GROUP_CCMP = 0x80;

        /// WPA/RSN Pre-Shared Key encryption is supported.
        const KEY_MGMT_PSK = 0x100;

        /// WPA/RSN 802.1x authentication and key management is supported.
        const KEY_MGMT_802_1X = 0x200;

        /// WPA/RSN Simultaneous Authentication of Equals (SAE) is supported.
        const KEY_MGMT_SAE = 0x400;

        /// Opportunistic Wireless Encryption (OWE) is supported.
        const KEY_MGMT_OWE = 0x800;

        /// Opportunistic Wireless Encryption (OWE) in transition mode is supported.
        const KEY_MGMT_OWE_TM = 0x1000;

        /// WPA3 Enterprise Suite-B 192 bit mode is supported.
        const KEY_MGMT_EAP_SUITE_B_192 = 0x2000;
    }
}

/// The 802.11 mode an access point can be in.
///
/// This is the same as [`WirelessClientMode`] internally to NetworkManager, but is exposed as a
/// different type in this API to differentiate between the two contexts it can be obtained in.
#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum AccessPointMode {
    /// The access point mode is unknown.
    Unknown = 0,

    /// Indicates the object is part of an Ad-Hoc 802.11 network without a central coordinating
    /// access point.
    AdHoc = 1,

    /// The access point is in infrastructure mode.
    ///
    /// This indicates the object is an access point that provides connectivity to clients.
    Infrastructure = 2,

    /// The access point is a 802.11s mesh point.
    Mesh = 4,
}

bitflags! {
    /// Flags describing Wi-Fi client capabilities and security properties.
    ///
    /// [DBus Service documentation](https://www.networkmanager.dev/docs/api/latest/nm-dbus-types.html#NMDeviceWifiCapabilities)
    #[repr(transparent)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct WirelessClientCapabilityFlags: u32 {
        /// 40/64-bit WEP encryption is supported.
        const CIPHER_WEP40 = 0x1;

        /// 104/128-bit WEP encryption is supported.
        const CIPHER_WEP104 = 0x2;

        /// TKIP encryption is supported.
        const CIPHER_TKIP = 0x4;

        /// AES/CCMP encryption is supported.
        const CIPHER_CCMP = 0x8;

        /// WPA1 authentication is supported.
        const WPA1 = 0x10;

        /// WPA2/RSN authentication is supported.
        const WPA2 = 0x20;

        /// Access point mode is supported.
        const AP = 0x40;

        /// Ad-Hoc mode is supported.
        const AD_HOC = 0x80;

        /// The device reports frequency capabilities.
        const FREQ_VALID = 0x100;

        /// The device supports 2.4 GHz frequencies.
        const FREQ_2GHZ = 0x200;

        /// The device supports 5 GHz frequencies.
        const FREQ_5GHZ = 0x400;

        /// The device supports acting as a mesh point.
        const MESH = 0x1000;

        /// The device supports WPA2/RSN in an IBSS network.
        const IBSS_RSN = 0x2000;
    }
}

/// The 802.11 mode a wireless client can be in.
///
/// This is the same as [`AccessPointMode`] internally to NetworkManager, but is exposed as a
/// different type in this API to differentiate between the two contexts it can be obtained in.
#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum WirelessClientMode {
    /// The device mode is unknown.
    Unknown = 0,

    /// Indicates the device is part of an Ad-Hoc 802.11 network without a central coordinating
    /// access point.
    AdHoc = 1,

    /// The device is in infrastructure mode.
    ///
    /// This indicates the device is an 802.11 client/station.
    Station = 2,

    /// The device is a hotspot.
    Hotspot = 3,

    /// The device is a 802.11s mesh point.
    Mesh = 4,
}

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// pub enum NMBluetoothCapabilities {
//     NmBtCapabilityNone = 0,
//     NmBtCapabilityDun = 1,
//     NmBtCapabilityNap = 2,
// }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// pub enum NMDeviceModemCapabilities {
//     NmDeviceModemCapabilityNone = 0,
//     NmDeviceModemCapabilityPots = 1,
//     NmDeviceModemCapabilityCdmaEvdo = 2,
//     NmDeviceModemCapabilityGsmUmts = 4,
//     NmDeviceModemCapabilityLte = 8,
// }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// pub enum NMWimaxNspNetworkType {
//     NmWimaxNspNetworkTypeUnknown = 0,
//     NmWimaxNspNetworkTypeHome = 1,
//     NmWimaxNspNetworkTypePartner = 2,
//     NmWimaxNspNetworkTypeRoamingPartner = 3,
// }

/// The metered state of a network device.
///
/// This is the same as [`MeteredSetting`] internally to NetworkManager, but is exposed as a
/// different type in this API to differentiate between the setting and the actual metered status.
#[derive(Clone, Copy, Debug, FromPrimitive)]
pub enum MeteredStatus {
    Unknown = 0,
    Yes = 1,
    No = 2,
    GuessYes = 3,
    GuessNo = 4,
}

/// The `connection.metered` setting.
///
/// This is the same as [`MeteredStatus`] internally to NetworkManager, but is exposed as a
/// different type in this API to differentiate between the setting and the actual metered status.
#[derive(Clone, Copy, Debug)]
pub enum MeteredSetting {
    Undecided = 0,
    Yes = 1,
    No = 2,
}

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMConnectionMultiConnect {
// //     NM_CONNECTION_MULTI_CONNECT_DEFAULT = 0,
// //     NM_CONNECTION_MULTI_CONNECT_SINGLE = 1,
// //     NM_CONNECTION_MULTI_CONNECT_MANUAL_MULTIPLE = 2,
// //     NM_CONNECTION_MULTI_CONNECT_MULTIPLE = 3,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMActiveConnectionStateReason {
// //     NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN = 0,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_NONE = 1,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED = 2,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED = 3,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED = 4,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID = 5,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT = 6,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT = 7,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED = 8,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS = 9,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED = 10,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED = 11,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED = 12,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED = 13,
// //     NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED = 14,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMSecretAgentGetSecretsFlags {
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE = 0,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION = 1,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW = 2,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED = 4,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_WPS_PBC_ACTIVE = 8,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM = 2147483648,
// //     NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS = 1073741824,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMSecretAgentCapabilities {
// //     NM_SECRET_AGENT_CAPABILITY_NONE = 0,
// //     NM_SECRET_AGENT_CAPABILITY_VPN_HINTS = 1,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMIPTunnelMode {
// //     NM_IP_TUNNEL_MODE_UNKNOWN = 0,
// //     NM_IP_TUNNEL_MODE_IPIP = 1,
// //     NM_IP_TUNNEL_MODE_GRE = 2,
// //     NM_IP_TUNNEL_MODE_SIT = 3,
// //     NM_IP_TUNNEL_MODE_ISATAP = 4,
// //     NM_IP_TUNNEL_MODE_VTI = 5,
// //     NM_IP_TUNNEL_MODE_IP6IP6 = 6,
// //     NM_IP_TUNNEL_MODE_IPIP6 = 7,
// //     NM_IP_TUNNEL_MODE_IP6GRE = 8,
// //     NM_IP_TUNNEL_MODE_VTI6 = 9,
// //     NM_IP_TUNNEL_MODE_GRETAP = 10,
// //     NM_IP_TUNNEL_MODE_IP6GRETAP = 11,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMCheckpointCreateFlags {
// //     NM_CHECKPOINT_CREATE_FLAG_NONE = 0,
// //     NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL = 1,
// //     NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS = 2,
// //     NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES = 4,
// //     NM_CHECKPOINT_CREATE_FLAG_ALLOW_OVERLAPPING = 8,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMRollbackResult {
// //     NM_ROLLBACK_RESULT_OK = 0,
// //     NM_ROLLBACK_RESULT_ERR_NO_DEVICE = 1,
// //     NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED = 2,
// //     NM_ROLLBACK_RESULT_ERR_FAILED = 3,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMSettingsAddConnection2Flags {
// //     NM_SETTINGS_ADD_CONNECTION2_FLAG_NONE = 0,
// //     NM_SETTINGS_ADD_CONNECTION2_FLAG_TO_DISK = 1,
// //     NM_SETTINGS_ADD_CONNECTION2_FLAG_IN_MEMORY = 2,
// //     NM_SETTINGS_ADD_CONNECTION2_FLAG_BLOCK_AUTOCONNECT = 32,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMSettingsUpdate2Flags {
// //     NM_SETTINGS_UPDATE2_FLAG_NONE = 0,
// //     NM_SETTINGS_UPDATE2_FLAG_TO_DISK = 1,
// //     NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY = 2,
// //     NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_DETACHED = 4,
// //     NM_SETTINGS_UPDATE2_FLAG_IN_MEMORY_ONLY = 8,
// //     NM_SETTINGS_UPDATE2_FLAG_VOLATILE = 16,
// //     NM_SETTINGS_UPDATE2_FLAG_BLOCK_AUTOCONNECT = 32,
// //     NM_SETTINGS_UPDATE2_FLAG_NO_REAPPLY = 64,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMTernary {
// //     NM_TERNARY_DEFAULT = -1,
// //     NM_TERNARY_FALSE = 0,
// //     NM_TERNARY_TRUE = 1,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMClientPermission {
// //     NM_CLIENT_PERMISSION_NONE = 0,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK = 1,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI = 2,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN = 3,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX = 4,
// //     NM_CLIENT_PERMISSION_SLEEP_WAKE = 5,
// //     NM_CLIENT_PERMISSION_NETWORK_CONTROL = 6,
// //     NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED = 7,
// //     NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN = 8,
// //     NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM = 9,
// //     NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN = 10,
// //     NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME = 11,
// //     NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS = 12,
// //     NM_CLIENT_PERMISSION_RELOAD = 13,
// //     NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK = 14,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS = 15,
// //     NM_CLIENT_PERMISSION_ENABLE_DISABLE_CONNECTIVITY_CHECK = 16,
// //     NM_CLIENT_PERMISSION_WIFI_SCAN = 17,
// // }

// #[derive(Clone, Copy, Debug, FromPrimitive)]
// // pub enum NMClientPermissionResult {
// //     NM_CLIENT_PERMISSION_RESULT_UNKNOWN = 0,
// //     NM_CLIENT_PERMISSION_RESULT_YES = 1,
// //     NM_CLIENT_PERMISSION_RESULT_AUTH = 2,
// //     NM_CLIENT_PERMISSION_RESULT_NO = 3,
// // }
